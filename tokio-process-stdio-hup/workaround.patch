diff --git src/main.rs src/main.rs
index ad09e35..ca425b5 100644
--- src/main.rs
+++ src/main.rs
@@ -6,6 +6,7 @@ use std::time::Duration;
 
 use tokio::prelude::*;
 use tokio::process::Command;
+use tokio::signal::unix as signal;
 
 #[tokio::main]
 async fn main() {
@@ -22,6 +23,7 @@ async fn main() {
         inner: child.stdin.take().unwrap(),
         writing: writing.clone(),
         shutdown: shutdown.clone(),
+        sigchld: signal::signal(signal::SignalKind::child()).unwrap(),
     };
 
     // Spawn a task which writes large amounts of data to `input`.
@@ -59,6 +61,7 @@ struct Wrapper<W> {
     inner: W,
     writing: Arc<Mutex<bool>>,
     shutdown: Arc<Mutex<bool>>,
+    sigchld: signal::Signal,
 }
 
 impl<W: AsyncWrite + Unpin> AsyncWrite for Wrapper<W> {
@@ -69,7 +72,18 @@ impl<W: AsyncWrite + Unpin> AsyncWrite for Wrapper<W> {
         buf: &[u8]
     ) -> Poll<io::Result<usize>> {
         let poll = Pin::new(&mut self.inner).poll_write(cx, buf);
-        *self.writing.lock().unwrap() = poll.is_pending();
+        if poll.is_pending() {
+            // Call `poll_recv()` in order to wake up the pending write when a
+            // child process terminated.  The pending write awakes even when
+            // the owner child process doesn't terminate, but there are no
+            // fatal adverse effects.
+            *self.writing.lock().unwrap() = true;
+            if Pin::new(&mut self.sigchld).poll_recv(cx).is_ready() {
+                return Poll::Ready(Ok(0));
+            }
+        } else {
+            *self.writing.lock().unwrap() = false;
+        }
         poll
     }
 
